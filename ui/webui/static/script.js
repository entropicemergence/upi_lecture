document.addEventListener('DOMContentLoaded', () => {
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-button');
    const chatHistory = document.getElementById('chat-history');

    let conversationHistory = null;
    let sessionId = null;

    // Auto-resize textarea
    messageInput.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = (this.scrollHeight) + 'px';
    });
    
    const sendMessage = async () => {
        const query = messageInput.value.trim();
        if (query === '') return;

        appendMessage('user', query);
        messageInput.value = '';
        messageInput.style.height = 'auto'; // Reset height
        
        showTypingIndicator();

        try {
            const response = await fetch('/chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ message: query, history: conversationHistory, session_id: sessionId }),
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(errorText || 'An unknown error occurred.');
            }
            
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            hideTypingIndicator();
            const agentMessageDiv = appendMessage('agent', '');
            let agentResponseText = '';
            let toolCallHTML = '';
            let isStreamingFinalAnswer = false;

            const processStream = async () => {
                let buffer = '';
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    
                    let boundary;
                    while ((boundary = buffer.indexOf('\n\n')) !== -1) {
                        const line = buffer.substring(0, boundary);
                        buffer = buffer.substring(boundary + 2);

                        if (line.startsWith('data: ')) {
                            const dataStr = line.substring(6);
                            if (dataStr.trim()) {
                                try {
                                    const data = JSON.parse(dataStr);
                                    if (data.type === 'token') {
                                        if (!isStreamingFinalAnswer) {
                                            isStreamingFinalAnswer = true;
                                            const typingIndicator = agentMessageDiv.querySelector('.typing-indicator-dots');
                                            if (typingIndicator) typingIndicator.remove();
                                        }
                                        agentResponseText += data.content;
                                        const processedText = agentResponseText.replace(/(\b\S+\.png\b)/g, (match, path) => {
                                            const plotUrl = `/plots/${path.split(/[\\/]/).pop()}`;
                                            return `\n\n<img src="${plotUrl}" alt="Plot generated by agent" style="max-width: 100%; border-radius: 8px; margin-top: 10px;" />`;
                                        });
                                        agentMessageDiv.querySelector('.text').innerHTML = toolCallHTML + marked.parse(processedText);
                                        chatHistory.scrollTop = chatHistory.scrollHeight;
                                    } else if (data.type === 'session_id') {
                                        sessionId = data.content;
                                    } else if (data.type === 'tool_call') {
                                        let argsDisplay = '';
                                        const args = data.data.arguments;
                                        if (args && Object.keys(args).length > 0) {
                                            let argsString = JSON.stringify(args);
                                            if (argsString.length > 30) {
                                                argsString = `${argsString.substring(0, 30)}...`;
                                            }
                                            argsDisplay = `<span class="tool-args">(${argsString})</span>`;
                                        }

                                        toolCallHTML += `
                                            <div class="tool-call-container">
                                                <div class="tool-call-header">
                                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tool-icon"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"></path></svg>
                                                    <span>ARA is calling <strong>${data.data.name} tool</strong> ${argsDisplay}</span>
                                                </div>
                                            </div>`;
                                        agentMessageDiv.querySelector('.text').innerHTML = toolCallHTML + '<div class="typing-indicator-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div>';
                                        chatHistory.scrollTop = chatHistory.scrollHeight;
                                    } else if (data.type === 'history') {
                                        conversationHistory = data.data;
                                    } else if (data.type === 'error') {
                                        agentResponseText += `**Error:**\n\n\`\`\`\n${data.content}\n\`\`\``;
                                        agentMessageDiv.querySelector('.text').innerHTML = marked.parse(agentResponseText);
                                        chatHistory.scrollTop = chatHistory.scrollHeight;
                                    }
                                } catch (e) {
                                    console.error("Failed to parse JSON from stream: ", dataStr, e);
                                    agentResponseText += `**Error:**\n\n\`\`\`\nReceived malformed data from server.\n\`\`\``;
                                    agentMessageDiv.querySelector('.text').innerHTML = marked.parse(agentResponseText);
                                    chatHistory.scrollTop = chatHistory.scrollHeight;
                                    return; // Stop processing on error
                                }
                            }
                        }
                    }
                }
            };
            
            await processStream();

        } catch (error) {
            console.error('Error:', error);
            hideTypingIndicator();
            appendMessage('agent', `**Error:**\n\n\`\`\`\n${error.message}\n\`\`\``);
        }
    };

    const appendMessage = (sender, text) => {
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('message', `${sender}-message`);

        const avatar = document.createElement('div');
        avatar.classList.add('avatar');
        avatar.textContent = sender === 'user' ? 'You' : 'ARA';

        const textDiv = document.createElement('div');
        textDiv.classList.add('text');
        textDiv.innerHTML = marked.parse(text);

        messageDiv.appendChild(avatar);
        messageDiv.appendChild(textDiv);
        chatHistory.appendChild(messageDiv);
        chatHistory.scrollTop = chatHistory.scrollHeight;
        return messageDiv;
    };

    const appendToolCallMessage = (toolName, toolArgs) => {
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('message', 'tool-call-message');

        const textDiv = document.createElement('div');
        textDiv.classList.add('text');
        
        textDiv.innerHTML = `
            <div class="tool-call-header">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tool-icon"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"></path></svg>
                <span>Calling tool: <strong>${toolName}</strong></span>
            </div>`;
        
        messageDiv.appendChild(textDiv);
        chatHistory.appendChild(messageDiv);
        chatHistory.scrollTop = chatHistory.scrollHeight;
    };

    const showTypingIndicator = () => {
        const typingDiv = document.createElement('div');
        typingDiv.id = 'typing-indicator';
        typingDiv.classList.add('message', 'agent-message');
        
        const avatar = document.createElement('div');
        avatar.classList.add('avatar');
        avatar.textContent = 'AI';
        
        const textDiv = document.createElement('div');
        textDiv.classList.add('text');
        textDiv.innerHTML = '<span class="dot"></span><span class="dot"></span><span class="dot"></span>';

        typingDiv.appendChild(avatar);
        typingDiv.appendChild(textDiv);
        chatHistory.appendChild(typingDiv);
        chatHistory.scrollTop = chatHistory.scrollHeight;
    };

    const hideTypingIndicator = () => {
        const indicator = document.getElementById('typing-indicator');
        if (indicator) {
            indicator.remove();
        }
    };

    sendButton.addEventListener('click', sendMessage);
    messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });
});




